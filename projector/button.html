<!DOCTYPE html>
<html>
  <head>
    <title>test</title>
    <script src="jquery.js"></script>
  </head>

  <body>
<img id="scream" src="the_scream.jpg" alt="The Scream" width="220" height="277" />
    <video id="video1" controls width="270" autoplay loop>
      <source src="mov_bbb.ogg" type='video/ogg' />
    </video>
    <canvas id="canvas" width="300" height="300"></canvas>
    <canvas id="canvas-source" width="640" height="480"></canvas>
    <canvas id="canvas-blended" width="640" height="480"></canvas>
    <video id="webcam" autoplay width="640" height="480"></video>
    <script type="text/javascript">
      var canvas = document.getElementById("canvas");

      var ctx = canvas.getContext("2d");
      ctx.fillStyle = "#FF0000";
      //ctx.fillRect(0, 0, 150, 75);

      function buttons() {
        this.listOfButtons = [];

        this.addButton = addButton;
        function addButton(button) {
          this.listOfButtons.push(button)
        }

        //this.deleteButton = deleteButton;
        //function deleteButton(button) {
        //  
        //}

        this.draw = draw;
        function draw() {
          for (i in this.listOfButtons) {
            this.listOfButtons[i].draw();
          }
        }

        this.checkPressed = checkPressed;
        function checkPressed(contextBlended, transform) {
          for (i in this.listOfButtons) {
            this.listOfButtons[i].checkPressed(contextBlended, transform);
          }
        }
      }

      function button(x, y, sizeX, sizeY, image, ctx) {
        this.sizeX = sizeX;
        this.sizeY = sizeY;
        this.x = x;
        this.y = y;
        this.method; // method to invoke when pressed
        this.image = image; // image to draw
        this.ctx = ctx

        this.draw = draw;
        function draw() {
          if (this.enabled) {
            this.ctx.strokeStyle = 'red'
          } else {
            this.ctx.strokeStyle = 'black'
          }
          this.ctx.strokeRect(x, y, sizeX, sizeY);
          this.ctx.drawImage(this.image, x, y, sizeX, sizeY);
        }

        this.checkPressed = checkPressed;
        this.pressed = false;
        this.enabled = true;
        function checkPressed(contextBlended, transform) {
          // TODO transform x, y, sizeX and sizeY
			    var blendedData = contextBlended.getImageData(this.x, this.y, this.sizeX, this.sizeY);
			    var i = 0;
			    var average = 0;
			    // loop over the pixels
			    while (i < (blendedData.data.length * 0.25)) {
				    // make an average between the color channel
		        average += (blendedData.data[i*4] + blendedData.data[i*4+1] + blendedData.data[i*4+2]) / 3;
		        ++i;
		      }
			    // calculate an average between of the color values of the note area
		      average = Math.round(average / (blendedData.data.length * 0.25));
          // TODO decide open a value
			    if (average > 10 && !this.pressed) {
            this.pressed = true;
            if (this.enabled) {
              this.enabled = false;
            } else {
              this.enabled = true;
            }
            this.draw()
            //method()
          } else {
            this.pressed = false;
          }
        }
      }

      function videoButton(x, y, sizeX, sizeY, video, ctx) {
        this.sizeX = sizeX;
        this.sizeY = sizeY;
        this.x = x;
        this.y = y;
        this.method; // method to invoke when pressed
        this.v = video; // image to draw
        this.count = 0;
        this.ctx = ctx;
        this.i; // handle for interval

        this.draw = draw;
        function draw() {
          this.ctx.strokeStyle = 'black';
          this.ctx.strokeRect(x, y, sizeX, sizeY);
          if (this.enabled) {
            this.first++;
            this.drawMovie()
            this.i = window.setInterval(this.drawMovie,  40);
          } else {
            window.clearInterval(this.i);
            this.ctx.fillRect(x, y, sizeX, sizeY);
          }
        }

        this.drawMovie = drawMovie;
        function drawMovie() {
          this.ctx.drawImage(v, x, y, sizeX, sizeY);
        }

        this.checkPressed = checkPressed;
        this.pressed = false;
        this.enabled = true;
        function checkPressed(contextBlended, transform) {
          // TODO transform x, y, sizeX and sizeY
			    var blendedData = contextBlended.getImageData(this.x, this.y, this.sizeX, this.sizeY);
			    var i = 0;
			    var average = 0;
			    // loop over the pixels
			    while (i < (blendedData.data.length * 0.25)) {
				    // make an average between the color channel
		        average += (blendedData.data[i*4] + blendedData.data[i*4+1] + blendedData.data[i*4+2]) / 3;
		        ++i;
		      }
			    // calculate an average between of the color values of the note area
		      average = Math.round(average / (blendedData.data.length * 0.25));
          // TODO decide open a value
			    if (average > 10 && !this.pressed) {
            this.pressed = true;
            if (this.enabled) {
              this.enabled = false;
            } else {
              this.enabled = true;
            }
            this.draw()
            //method()
          } else {
            this.pressed = false;
          }
			  }
      }


      function test() {
        alert("test");
      }
      image = document.getElementById("scream");
      v = document.getElementById("video1");
      var button1 = new button(10, 10, 10, 10, image, ctx);
      var button2 = new button(20, 20, 100, 100, image, ctx);
      var buttons = new buttons();
      button1.method = test;
      button2.method = test;

      var button3 = new videoButton(120, 120, 100, 100, v, ctx);

      buttons.addButton(button1);
      buttons.addButton(button2);
      buttons.addButton(button3);
      buttons.draw();

	function hasGetUserMedia() {
		// Note: Opera builds are unprefixed.
		return !!(navigator.getUserMedia || navigator.webkitGetUserMedia ||
			navigator.mozGetUserMedia || navigator.msGetUserMedia);
	}

	if (hasGetUserMedia()) {
		$("#info").hide();
		$("#message").show();
	} else {
		$("#info").show();
		$("#message").hide();
		$("#video-demo").show();
		$("#video-demo")[0].play();
		return;
	}

	var webcamError = function(e) {
		alert('Webcam error!', e);
	};

	var video = $('#webcam')[0];

	if (navigator.getUserMedia) {
		navigator.getUserMedia({audio: true, video: true}, function(stream) {
			video.src = stream;
			initialize();
		}, webcamError);
	} else if (navigator.webkitGetUserMedia) {
		navigator.webkitGetUserMedia({audio: true, video: true}, function(stream) {
			video.src = window.webkitURL.createObjectURL(stream);
			initialize();
		}, webcamError);
	} else {
		//video.src = 'somevideo.webm'; // fallback.
	}


	    var video = $('#webcam')[0];

      var timeOut, lastImageData;
      var canvasSource = $("#canvas-source")[0];
      var canvasBlended = $("#canvas-blended")[0];

      var contextSource = canvasSource.getContext('2d');
      var contextBlended = canvasBlended.getContext('2d');

      contextSource.translate(canvasSource.width, 0);
      contextSource.scale(-1, 1);
      start()

      function initialize() {
        start()
      }
       
      function start() {
        $(canvasSource).hide();
        $(canvasBlended).show();
        $(video).hide()
        update();
      }

      function update() {
        drawVideo();
        blend();
        buttons.checkPressed(contextBlended, 1)
        timeOut = setTimeout(update, 1000/60);
      }

      function drawVideo() {
        contextSource.drawImage(video, 0, 0, video.width, video.height);
      }

      function blend() {
        var width = canvasSource.width;
        var height = canvasSource.height;
        // get webcam image data
        var sourceData = contextSource.getImageData(0, 0, width, height);
        // create an image if the previous image doesnâ€™t exist
        if (!lastImageData) lastImageData = contextSource.getImageData(0, 0, width, height);
        // create a ImageData instance to receive the blended result
        var blendedData = contextSource.createImageData(width, height);
        // blend the 2 images
        differenceAccuracy(blendedData.data, sourceData.data, lastImageData.data);
        // draw the result in a canvas
        contextBlended.putImageData(blendedData, 0, 0);
        // store the current webcam image
        lastImageData = sourceData;
      }

      function fastAbs(value) {
        // funky bitwise, equal Math.abs
        return (value ^ (value >> 31)) - (value >> 31);
      }

      function threshold(value) {
        // TODO change accordingly
        return (value > 0x1F) ? 0xFF : 0;
      }

      function difference(target, data1, data2) {
      // blend mode difference
      if (data1.length != data2.length) return null;
      var i = 0;
      while (i < (data1.length * 0.25)) {
        target[4*i] = data1[4*i] == 0 ? 0 : fastAbs(data1[4*i] - data2[4*i]);
        target[4*i+1] = data1[4*i+1] == 0 ? 0 : fastAbs(data1[4*i+1] - data2[4*i+1]);
        target[4*i+2] = data1[4*i+2] == 0 ? 0 : fastAbs(data1[4*i+2] - data2[4*i+2]);
        target[4*i+3] = 0xFF;
        ++i;
      }
    }

    function differenceAccuracy(target, data1, data2) {
      if (data1.length != data2.length) return null;
      var i = 0;
      while (i < (data1.length * 0.25)) {
        var average1 = (data1[4*i] + data1[4*i+1] + data1[4*i+2]) / 3;
        var average2 = (data2[4*i] + data2[4*i+1] + data2[4*i+2]) / 3;
        var diff = threshold(fastAbs(average1 - average2));
        target[4*i] = diff;
        target[4*i+1] = diff;
        target[4*i+2] = diff;
        target[4*i+3] = 0xFF;
        ++i;
      }
    }


</script>


  </body>
</html>

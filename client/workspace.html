<html>
<head>
<title>Workspace view</title>
<link type="text/css" href="css/workspacestyle.css" rel="stylesheet"></link>
<link href="http://ajax.googleapis.com/ajax/libs/jqueryui/1.8/themes/base/jquery-ui.css" rel="stylesheet" type="text/css" />
<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.8/jquery.min.js"></script>
<script	src="http://ajax.googleapis.com/ajax/libs/jqueryui/1.8/jquery-ui.min.js"></script>
<script src="js/lib/sylvester.js"></script>
<script type="text/javascript" src="js/mediaext.js"></script>
<script type="text/javascript" src="js/geometry.js"></script>
<script type="text/javascript" src="js/cv.js"></script>
<script type="text/javascript" src="js/aruco.js"></script>
<script type="text/javascript" src="js/imageproc.js"></script>
<script type="text/javascript" src="js/buttons.js"></script>
<script type="text/javascript" src="js/calibration.js"></script>
<script src="/webrtc.io.js"></script>
</head>
<body style="font-family: monospace; background-color: white;">
<div id="notice">This is the workspace view. Choose the appropriate camera and move this window to where you want it.</div>
<div>
<button id="fullscreen">Enter Full Screen</button>
</div>
<center>
<canvas id ="myCanvas" style="width: 100%; height: 100%"></canvas>
<div>
<button id="button">Done Calibrating</button>
</div>
</center>
<script>

const CANVAS_WIDTH = 640, CANVAS_HEIGHT = 480;

// hide and show correct html elements
var c = $('#myCanvas');
c.hide();

var fullscreen = $('#fullscreen');

var doneCalibration = $('#button');
doneCalibration.hide();

var notice = $('#notice');

function Workspace() {
	var video, detector, imageData;
	var buttons;
	var miniCanvas, miniContext;
	var fullCanvas, fullContext;
	var calibrator;
	var imageData;
	var videos = [];
	var videoStreams = [];
	var PeerConnection = window.PeerConnection || window.webkitPeerConnection00;

	this.cloneVideo = function (socketId) {
		var video = document.createElement('video');
    	video.width = CANVAS_WIDTH;
    	video.height = CANVAS_HEIGHT;
    	video.autoplay = true;
		if (socketId == 'you') {
			video.id = 'you';
		} else {
			video.id = "remote" + socketId;
		}
		videos.push(video);
		return video;
	}

	this.removeVideo = function (socketId) {
		var index = -1;
		for (var i = 0; i < videos.length; i++) {
			if (videos[i].id == 'remote' + socketId) {
				index = i;
				break;
			}
		}
		if (index > -1) {
			videoStreams.splice(index, 1);
			videos.splice(index, 1);
		}
	}

	this.initFullScreen = function () { 
		var self = this;
		fullscreen.click(function(event) {
				// TODO enter full screen 
				notice.hide();
				fullscreen.hide();
				// enable calibration button
				doneCalibration.click(function(event) {
					self.finishedCalibration();
				});
				doneCalibration.show();
				self.startCalibration();
				// TODO start merging video and display it
				});
	} 

	this.finishedCalibration = function () {
		calibrator.confirmSharedRectangle();
	}

	this.init = function () {
		if (PeerConnection) {
			var self = this;

			rtc.createStream({"video": true, "audio": true}, function(stream) {
					var v = self.cloneVideo('you');
					v.src = URL.createObjectURL(stream);
					videos.push(v);
					video = v;
					// TODO fix this, add a video tag and hide it
					//rtc.attachStream(stream, 'you');
					videoStreams.push(stream);
					});
		} else {
			alert('Your browser is not supported or you have to turn on flags. In chrome you go to chrome://flags and turn on Enable PeerConnection remember to restart chrome');
		}

		var room = window.location.hash.slice(1);
		var self = this;

		//When using localhost
		console.log('Connecting');
		rtc.connect("ws://"+ window.location.host +"/", room);

		rtc.on('add remote stream', function(stream, socketId) {
				console.log("ADDING REMOTE STREAM...");
				var clone = self.cloneVideo(socketId);
				clone.class="";
				var streamUrl = URL.createObjectURL(stream);
				clone.setAttribute("src", streamUrl);
				videoStreams.push(stream);
				});
		rtc.on('disconnect stream', function(data) {
				console.log('remove ' + data);
				self.removeVideo(data);
				});
		this.initFullScreen();
	}

	this.getVideos = function() {
		return videos;
	}

	this.getVideoStreams = function() {
		return videoStreams;
	}

	this.getPeerConnection = function() {
		return PeerConnection;
	}

	this.startCalibration = function() {
		c.show();

		miniCanvas = MediaExt.createCanvas(CANVAS_WIDTH, CANVAS_HEIGHT);
		miniContext = miniCanvas.getContext("2d");

		fullCanvas = document.getElementById("myCanvas");
		fullContext = fullCanvas.getContext("2d");

		detector = new AR.Detector();
		calibrator = new Calibrator(fullCanvas, video);

		fullCanvas.width = window.innerWidth;
		fullCanvas.height = window.innerHeight;

		window.onresize = function() {
			fullCanvas.width = window.innerWidth;
			fullCanvas.height = window.innerHeight;
		};
		this.tick();
	}


	// Stores an image from the local video stream in imageData
	this.snapshot = function() {

		// Draw video to an offscreen canvas, marker detection is done there
		miniContext.drawImage(video, 0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
		imageData = miniContext.getImageData(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

		calibrator.draw(imageData);
	}

	/* Keeps calibrating until the correct rectangle is found,
	   then displays the transformed video stream */
	this.tick = function() {
		console.log('tick');
		this.snapshot();
		var markers = detector.detect(imageData);
		calibrator.calibrateWithMarkers(markers);
		var self = this;
		setTimeout(function() {self.tick();}, 1);
	}
}

workspace = new Workspace();
workspace.init();

window.opener.parent.socket.on(window.opener.parent.socket.API_CORNERS_BROADCAST, function(msg, videoLabel) {
		// func to projectors here...
		console.log("");


		var label = workspace.getVideoStreams()[0].label;

		var message = "My corners";

		var data = JSON.stringify({
id: id,
msg: message,
videoLabel: label
});

		// This should be run inside the function that calculates the corners.
		//window.opener.parent.Socket.send(window.opener.parent.socket.API_CORNERS, data);

		});

window.opener.parent.socket.on(window.opener.parent.socket.API_CORNERS, function(id, msg, videoLabel) {
		// func to projectors here...
		console.log(videoLabel);

		});

</script>
</body>
</html>
